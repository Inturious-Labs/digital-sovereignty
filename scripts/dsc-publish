#!/bin/bash

# DSC Publish - Validate and prepare article for publishing
# Run this from within an article folder or pass the article path as argument
# 1. Validates frontmatter, content, and images
# 2. Prompts for publication date
# 3. Sets draft: false

set -e

# Colors
RED=$'\e[0;31m'
GREEN=$'\e[0;32m'
YELLOW=$'\e[1;33m'
PINK=$'\e[38;5;212m'
BLUE=$'\e[0;34m'
GRAY=$'\e[0;90m'
NC=$'\e[0m'
BOLD=$'\e[1m'

# Counters
ERRORS=0
WARNINGS=0

error() {
    echo -e "${RED}[ERROR]${NC} $1"
    ((ERRORS++)) || true
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
    ((WARNINGS++)) || true
}

ok() {
    echo -e "${GREEN}[OK]${NC} $1"
}

info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Find repo root
find_repo_root() {
    local dir="$PWD"
    while [ "$dir" != "/" ]; do
        if [ -f "$dir/hugo.toml" ] && [ -d "$dir/content/posts" ]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

# Determine article directory
if [ -n "$1" ]; then
    ARTICLE_DIR="$1"
else
    ARTICLE_DIR="$PWD"
fi

# Resolve to absolute path
ARTICLE_DIR=$(cd "$ARTICLE_DIR" 2>/dev/null && pwd) || {
    echo -e "${RED}Error: Cannot access directory: $1${NC}"
    exit 1
}

REPO_ROOT=$(find_repo_root)
if [ -z "$REPO_ROOT" ]; then
    echo -e "${RED}Error: Not inside the DSC repository${NC}"
    exit 1
fi

INDEX_FILE="$ARTICLE_DIR/index.md"

echo -e "${BLUE}${BOLD}DSC Publish${NC}"
echo -e "${GRAY}Article: $ARTICLE_DIR${NC}"
echo ""

# Check index.md exists
if [ ! -f "$INDEX_FILE" ]; then
    error "index.md not found in $ARTICLE_DIR"
    echo ""
    echo -e "${RED}Audit failed: No article to audit${NC}"
    exit 1
fi

echo -e "${BOLD}Frontmatter Checks${NC}"
echo "─────────────────────────────────────"

# Extract frontmatter
FRONTMATTER=$(awk '/^---$/{if(f)exit;f=1;next}f' "$INDEX_FILE")

# Check required fields
check_field() {
    local field="$1"
    local value=$(echo "$FRONTMATTER" | grep "^$field:" | head -1 | sed "s/^$field: //" | sed 's/^"//' | sed 's/"$//')

    if [ -z "$value" ]; then
        error "Missing required field: $field"
        return 1
    fi
    return 0
}

# Title
if check_field "title"; then
    TITLE=$(echo "$FRONTMATTER" | grep "^title:" | sed 's/^title: "//' | sed 's/"$//')
    ok "Title: $TITLE"
fi

# Date
DATE_LINE=$(echo "$FRONTMATTER" | grep "^date:")
if [ -z "$DATE_LINE" ]; then
    error "Missing date field"
else
    DATE_VAL=$(echo "$DATE_LINE" | sed 's/^date: //')
    if [[ "$DATE_VAL" == "2099-12-31"* ]]; then
        warn "Date is placeholder (2099-12-31) - update before publishing"
    else
        ok "Date: $DATE_VAL"
    fi
fi

# Slug
if check_field "slug"; then
    SLUG=$(echo "$FRONTMATTER" | grep "^slug:" | sed 's/^slug: //')
    ok "Slug: $SLUG"
fi

# Draft status
DRAFT=$(echo "$FRONTMATTER" | grep "^draft:" | sed 's/^draft: //')
if [ "$DRAFT" = "true" ]; then
    info "Draft: true (set to false when ready to publish)"
else
    ok "Draft: false (ready to publish)"
fi

# Description
DESC=$(echo "$FRONTMATTER" | grep "^description:" | sed 's/^description: "//' | sed 's/"$//')
if [ -z "$DESC" ] || [ "$DESC" = "Brief description of the post" ]; then
    warn "Description is missing or placeholder - add for SEO"
else
    DESC_LEN=${#DESC}
    if [ "$DESC_LEN" -lt 50 ]; then
        warn "Description is short ($DESC_LEN chars) - aim for 50-160 chars"
    elif [ "$DESC_LEN" -gt 160 ]; then
        warn "Description is long ($DESC_LEN chars) - may be truncated in search results"
    else
        ok "Description: $DESC_LEN chars"
    fi
fi

# Categories
CATEGORIES=$(echo "$FRONTMATTER" | grep -A1 "^categories:" | tail -1 | sed 's/.*"\(.*\)".*/\1/')
if [ -z "$CATEGORIES" ]; then
    warn "No categories found"
else
    ok "Category: $CATEGORIES"
fi

# Series (optional)
SERIES=$(echo "$FRONTMATTER" | grep -A1 "^series:" | tail -1 | sed 's/.*"\(.*\)".*/\1/' 2>/dev/null)
if [ -n "$SERIES" ]; then
    ok "Series: $SERIES"
fi

echo ""
echo -e "${BOLD}Content Checks${NC}"
echo "─────────────────────────────────────"

# Word count (excluding frontmatter)
CONTENT=$(awk '/^---$/{if(f){p=1;next}f=1;next}p' "$INDEX_FILE")
WORD_COUNT=$(echo "$CONTENT" | wc -w | tr -d ' ')

if [ "$WORD_COUNT" -lt 100 ]; then
    warn "Article is very short ($WORD_COUNT words)"
elif [ "$WORD_COUNT" -lt 300 ]; then
    info "Article: $WORD_COUNT words (consider expanding)"
else
    ok "Word count: $WORD_COUNT words"
fi

# Check for placeholder content
if echo "$CONTENT" | grep -q "## Introduction" && ! echo "$CONTENT" | grep -A2 "## Introduction" | grep -qv "^##\|^$"; then
    warn "Introduction section appears empty"
fi

if echo "$CONTENT" | grep -q "## Main Content" && ! echo "$CONTENT" | grep -A2 "## Main Content" | grep -qv "^##\|^$"; then
    warn "Main Content section appears empty"
fi

if echo "$CONTENT" | grep -q "## Conclusion" && ! echo "$CONTENT" | grep -A2 "## Conclusion" | grep -qv "^##\|^$"; then
    warn "Conclusion section appears empty"
fi

echo ""
echo -e "${BOLD}Image Checks${NC}"
echo "─────────────────────────────────────"

# Check for images in folder
IMAGE_COUNT=$(find "$ARTICLE_DIR" -maxdepth 1 \( -name "*.webp" -o -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" \) 2>/dev/null | wc -l | tr -d ' ')

if [ "$IMAGE_COUNT" -eq 0 ]; then
    warn "No images found in article folder"
else
    ok "Found $IMAGE_COUNT image(s)"
fi

# Check for featured image
if [ -f "$ARTICLE_DIR/featured-image.webp" ]; then
    ok "Featured image: featured-image.webp"
elif [ -f "$ARTICLE_DIR/hero.webp" ]; then
    ok "Featured image: hero.webp"
elif [ -f "$ARTICLE_DIR/hero.jpeg" ] || [ -f "$ARTICLE_DIR/hero.jpg" ]; then
    ok "Featured image: hero.jpeg/jpg"
else
    warn "No featured image (featured-image.webp or hero.webp) found"
fi

# Check for broken image references in content
REFERENCED_IMAGES=$(echo "$CONTENT" | grep -oE '!\[.*\]\(\./[^)]+\)' | sed 's/.*(\.\///' | sed 's/)$//' || true)
if [ -n "$REFERENCED_IMAGES" ]; then
    while IFS= read -r img; do
        if [ ! -f "$ARTICLE_DIR/$img" ]; then
            error "Referenced image not found: $img"
        fi
    done <<< "$REFERENCED_IMAGES"
fi

# Check images field in frontmatter
IMAGES_FIELD=$(echo "$FRONTMATTER" | grep "^images:" | sed 's/^images: //')
if [ "$IMAGES_FIELD" = '[""]' ] || [ -z "$IMAGES_FIELD" ]; then
    warn "images field in frontmatter is empty (used for social sharing)"
fi

echo ""
echo -e "${BOLD}File Checks${NC}"
echo "─────────────────────────────────────"

# Check for backup files
BACKUP_COUNT=$(find "$ARTICLE_DIR" -name "*.bak" -o -name "*~" -o -name "*.orig" 2>/dev/null | wc -l | tr -d ' ')
if [ "$BACKUP_COUNT" -gt 0 ]; then
    warn "Found $BACKUP_COUNT backup file(s) - consider removing before commit"
fi

# Check for HEIC files (should be converted)
HEIC_COUNT=$(find "$ARTICLE_DIR" -iname "*.heic" 2>/dev/null | wc -l | tr -d ' ')
if [ "$HEIC_COUNT" -gt 0 ]; then
    warn "Found $HEIC_COUNT HEIC file(s) - convert to WebP for web"
fi

# Article folder name check
FOLDER_NAME=$(basename "$ARTICLE_DIR")
if [[ ! "$FOLDER_NAME" =~ ^[0-9]{2}- ]]; then
    warn "Folder name doesn't follow DD-slug pattern: $FOLDER_NAME"
else
    ok "Folder naming: $FOLDER_NAME"
fi

echo ""
echo "═══════════════════════════════════════"

# Summary of audit
if [ "$ERRORS" -gt 0 ]; then
    echo -e "${RED}${BOLD}AUDIT FAILED${NC}"
    echo -e "${RED}$ERRORS error(s), $WARNINGS warning(s)${NC}"
    echo ""
    echo "Fix errors before publishing."
    exit 1
fi

if [ "$WARNINGS" -gt 0 ]; then
    echo -e "${YELLOW}${BOLD}AUDIT PASSED WITH WARNINGS${NC}"
    echo -e "${YELLOW}$WARNINGS warning(s)${NC}"
else
    echo -e "${GREEN}${BOLD}AUDIT PASSED${NC}"
fi

echo ""
echo -e "${BOLD}Prepare for Publishing${NC}"
echo "─────────────────────────────────────"

# Prompt for final title
CURRENT_TITLE=$(echo "$FRONTMATTER" | grep "^title:" | sed 's/^title: "//' | sed 's/"$//')
echo -e "${GREEN}Current title:${NC} $CURRENT_TITLE"
printf "${GREEN}Final title${NC} ${GRAY}[Enter to keep]:${NC} "
read -r new_title
if [ -n "$new_title" ]; then
    # Escape special characters for sed
    escaped_old=$(printf '%s\n' "$CURRENT_TITLE" | sed 's/[[\.*^$()+?{|]/\\&/g')
    escaped_new=$(printf '%s\n' "$new_title" | sed 's/[&/\]/\\&/g')
    sed -i '' "s/^title: \"${escaped_old}\"/title: \"${escaped_new}\"/" "$INDEX_FILE"
    TITLE="$new_title"
    echo -e "${GREEN}[OK]${NC} Title updated to: ${PINK}$new_title${NC}"
else
    echo -e "${BLUE}[OK]${NC} Title: ${PINK}$CURRENT_TITLE${NC}"
fi

# Auto-set publication date and time from system clock
NEW_DATE=$(date +%Y-%m-%dT%H:%M:%S+08:00)
sed -i '' "s/^date: .*/date: ${NEW_DATE}/" "$INDEX_FILE"
echo -e "${GREEN}[OK]${NC} Date set to: ${PINK}$NEW_DATE${NC}"

# Set draft: false
sed -i '' 's/^draft: true/draft: false/' "$INDEX_FILE"
echo -e "${GREEN}[OK]${NC} Draft set to: ${PINK}false${NC}"

echo ""
echo "═══════════════════════════════════════"
echo -e "${GREEN}${BOLD}READY TO PUBLISH${NC}"
echo ""
echo -e "Next steps:"
echo -e "  ${YELLOW}git add .${NC}"
echo -e "  ${YELLOW}git commit -m \"Publish: $TITLE\"${NC}"
echo -e "  ${YELLOW}git push${NC}"
echo -e "  ${YELLOW}gh pr create --base main --title \"Publish: $TITLE\"${NC}"
